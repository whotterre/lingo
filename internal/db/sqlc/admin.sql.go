// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: admin.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO
    admins (
        first_name,
        last_name,
        email,
        password,
        profile_image_url
    )
VALUES ($1, $2, $3, $4, $5) RETURNING admin_id, first_name, last_name, email, password, profile_image_url, joined_at
`

type CreateAdminParams struct {
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Password        string      `json:"password"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (Admin, error) {
	row := q.db.QueryRow(ctx, createAdmin,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.ProfileImageUrl,
	)
	var i Admin
	err := row.Scan(
		&i.AdminID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.ProfileImageUrl,
		&i.JoinedAt,
	)
	return i, err
}

const createCourse = `-- name: CreateCourse :one
INSERT INTO
    courses (
        course_name,
        language_id,
        difficulty_level,
        is_free
    )
VALUES ($1, $2, $3, $4) RETURNING course_id, language_id, course_name, difficulty_level, is_free, created_at
`

type CreateCourseParams struct {
	CourseName      string      `json:"course_name"`
	LanguageID      pgtype.UUID `json:"language_id"`
	DifficultyLevel pgtype.Text `json:"difficulty_level"`
	IsFree          pgtype.Bool `json:"is_free"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, createCourse,
		arg.CourseName,
		arg.LanguageID,
		arg.DifficultyLevel,
		arg.IsFree,
	)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.LanguageID,
		&i.CourseName,
		&i.DifficultyLevel,
		&i.IsFree,
		&i.CreatedAt,
	)
	return i, err
}

const createExercise = `-- name: CreateExercise :one
INSERT INTO
    exercises (
        lesson_id,
        exercise_type,
        question_text,
        correct_answer,
        options,
        audio_url
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING exercise_id, lesson_id, exercise_type, question_text, correct_answer, options, audio_url
`

type CreateExerciseParams struct {
	LessonID      pgtype.UUID `json:"lesson_id"`
	ExerciseType  pgtype.Text `json:"exercise_type"`
	QuestionText  string      `json:"question_text"`
	CorrectAnswer string      `json:"correct_answer"`
	Options       []byte      `json:"options"`
	AudioUrl      pgtype.Text `json:"audio_url"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.LessonID,
		arg.ExerciseType,
		arg.QuestionText,
		arg.CorrectAnswer,
		arg.Options,
		arg.AudioUrl,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.LessonID,
		&i.ExerciseType,
		&i.QuestionText,
		&i.CorrectAnswer,
		&i.Options,
		&i.AudioUrl,
	)
	return i, err
}

const createLanguage = `-- name: CreateLanguage :one

INSERT INTO
    languages (
        language_name,
        language_code,
        flag_emoji,
        description
    )
VALUES ($1, $2, $3, $4) RETURNING language_id, language_name, language_code, flag_emoji, description
`

type CreateLanguageParams struct {
	LanguageName string      `json:"language_name"`
	LanguageCode string      `json:"language_code"`
	FlagEmoji    pgtype.Text `json:"flag_emoji"`
	Description  pgtype.Text `json:"description"`
}

// Maintenance Functionality --
// Creational Queries
func (q *Queries) CreateLanguage(ctx context.Context, arg CreateLanguageParams) (Language, error) {
	row := q.db.QueryRow(ctx, createLanguage,
		arg.LanguageName,
		arg.LanguageCode,
		arg.FlagEmoji,
		arg.Description,
	)
	var i Language
	err := row.Scan(
		&i.LanguageID,
		&i.LanguageName,
		&i.LanguageCode,
		&i.FlagEmoji,
		&i.Description,
	)
	return i, err
}

const createLesson = `-- name: CreateLesson :one
INSERT INTO
    lessons (
        lesson_title,
        course_id,
        lesson_order,
        xp_reward,
        is_unlocked
    )
VALUES ($1, $2, $3, $4, $5) RETURNING lesson_id, course_id, lesson_title, lesson_order, xp_reward, is_unlocked
`

type CreateLessonParams struct {
	LessonTitle string      `json:"lesson_title"`
	CourseID    pgtype.UUID `json:"course_id"`
	LessonOrder int32       `json:"lesson_order"`
	XpReward    pgtype.Int4 `json:"xp_reward"`
	IsUnlocked  pgtype.Bool `json:"is_unlocked"`
}

func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, createLesson,
		arg.LessonTitle,
		arg.CourseID,
		arg.LessonOrder,
		arg.XpReward,
		arg.IsUnlocked,
	)
	var i Lesson
	err := row.Scan(
		&i.LessonID,
		&i.CourseID,
		&i.LessonTitle,
		&i.LessonOrder,
		&i.XpReward,
		&i.IsUnlocked,
	)
	return i, err
}

const createUserCourse = `-- name: CreateUserCourse :one
INSERT INTO
    user_courses (
        user_id,
        course_id,
        enrollment_date,
        completion_percentage
    )
VALUES (
        $1,
        $2,
        CURRENT_TIMESTAMP,
        0.0
    ) RETURNING user_course_id, user_id, course_id, enrollment_date, completion_percentage
`

type CreateUserCourseParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	CourseID pgtype.UUID `json:"course_id"`
}

func (q *Queries) CreateUserCourse(ctx context.Context, arg CreateUserCourseParams) (UserCourse, error) {
	row := q.db.QueryRow(ctx, createUserCourse, arg.UserID, arg.CourseID)
	var i UserCourse
	err := row.Scan(
		&i.UserCourseID,
		&i.UserID,
		&i.CourseID,
		&i.EnrollmentDate,
		&i.CompletionPercentage,
	)
	return i, err
}

const createUserProgress = `-- name: CreateUserProgress :one
INSERT INTO
    user_progress (
        user_id,
        lesson_id,
        score,
        completed_at
    )
VALUES ($1, $2, $3, $4) RETURNING progress_id, user_id, lesson_id, exercise_id, is_completed, score, completed_at
`

type CreateUserProgressParams struct {
	UserID      pgtype.UUID      `json:"user_id"`
	LessonID    pgtype.UUID      `json:"lesson_id"`
	Score       pgtype.Int4      `json:"score"`
	CompletedAt pgtype.Timestamp `json:"completed_at"`
}

func (q *Queries) CreateUserProgress(ctx context.Context, arg CreateUserProgressParams) (UserProgress, error) {
	row := q.db.QueryRow(ctx, createUserProgress,
		arg.UserID,
		arg.LessonID,
		arg.Score,
		arg.CompletedAt,
	)
	var i UserProgress
	err := row.Scan(
		&i.ProgressID,
		&i.UserID,
		&i.LessonID,
		&i.ExerciseID,
		&i.IsCompleted,
		&i.Score,
		&i.CompletedAt,
	)
	return i, err
}

const deleteAdmin = `-- name: DeleteAdmin :exec
DELETE FROM admins
WHERE
    admin_id = $1 RETURNING admin_id,
    first_name,
    last_name,
    email,
    profile_image_url,
    joined_at
`

func (q *Queries) DeleteAdmin(ctx context.Context, adminID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAdmin, adminID)
	return err
}

const getAdminByEmail = `-- name: GetAdminByEmail :one
SELECT
    admin_id,
    first_name,
    last_name,
    email,
    profile_image_url,
    joined_at
FROM admins
WHERE
    email = $1
LIMIT 1
`

type GetAdminByEmailRow struct {
	AdminID         pgtype.UUID      `json:"admin_id"`
	FirstName       string           `json:"first_name"`
	LastName        string           `json:"last_name"`
	Email           string           `json:"email"`
	ProfileImageUrl pgtype.Text      `json:"profile_image_url"`
	JoinedAt        pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetAdminByEmail(ctx context.Context, email string) (GetAdminByEmailRow, error) {
	row := q.db.QueryRow(ctx, getAdminByEmail, email)
	var i GetAdminByEmailRow
	err := row.Scan(
		&i.AdminID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.ProfileImageUrl,
		&i.JoinedAt,
	)
	return i, err
}

const getAdminById = `-- name: GetAdminById :one
SELECT
    admin_id,
    first_name,
    last_name,
    email,
    profile_image_url,
    joined_at
FROM admins
WHERE
    admin_id = $1
LIMIT 1
`

type GetAdminByIdRow struct {
	AdminID         pgtype.UUID      `json:"admin_id"`
	FirstName       string           `json:"first_name"`
	LastName        string           `json:"last_name"`
	Email           string           `json:"email"`
	ProfileImageUrl pgtype.Text      `json:"profile_image_url"`
	JoinedAt        pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetAdminById(ctx context.Context, adminID pgtype.UUID) (GetAdminByIdRow, error) {
	row := q.db.QueryRow(ctx, getAdminById, adminID)
	var i GetAdminByIdRow
	err := row.Scan(
		&i.AdminID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.ProfileImageUrl,
		&i.JoinedAt,
	)
	return i, err
}

const getAdminForLogin = `-- name: GetAdminForLogin :one
SELECT admin_id, email, password
FROM admins
WHERE
    email = $1
LIMIT 1
`

type GetAdminForLoginRow struct {
	AdminID  pgtype.UUID `json:"admin_id"`
	Email    string      `json:"email"`
	Password string      `json:"password"`
}

func (q *Queries) GetAdminForLogin(ctx context.Context, email string) (GetAdminForLoginRow, error) {
	row := q.db.QueryRow(ctx, getAdminForLogin, email)
	var i GetAdminForLoginRow
	err := row.Scan(&i.AdminID, &i.Email, &i.Password)
	return i, err
}

const getAllAdmins = `-- name: GetAllAdmins :many
SELECT
    admin_id,
    first_name,
    last_name,
    email,
    profile_image_url,
    joined_at
FROM admins
ORDER BY joined_at DESC
LIMIT $1
OFFSET
    $2
`

type GetAllAdminsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllAdminsRow struct {
	AdminID         pgtype.UUID      `json:"admin_id"`
	FirstName       string           `json:"first_name"`
	LastName        string           `json:"last_name"`
	Email           string           `json:"email"`
	ProfileImageUrl pgtype.Text      `json:"profile_image_url"`
	JoinedAt        pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetAllAdmins(ctx context.Context, arg GetAllAdminsParams) ([]GetAllAdminsRow, error) {
	rows, err := q.db.Query(ctx, getAllAdmins, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAdminsRow{}
	for rows.Next() {
		var i GetAllAdminsRow
		if err := rows.Scan(
			&i.AdminID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.ProfileImageUrl,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLanguages = `-- name: GetAllLanguages :many

SELECT
    language_id,
    language_name,
    language_code,
    flag_emoji,
    description
FROM languages
ORDER BY language_name ASC
LIMIT $1
OFFSET
    $2
`

type GetAllLanguagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Retrieval Queries
func (q *Queries) GetAllLanguages(ctx context.Context, arg GetAllLanguagesParams) ([]Language, error) {
	rows, err := q.db.Query(ctx, getAllLanguages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Language{}
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.LanguageID,
			&i.LanguageName,
			&i.LanguageCode,
			&i.FlagEmoji,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguageById = `-- name: GetLanguageById :one
SELECT
    language_id,
    language_name,
    language_code,
    flag_emoji,
    description
FROM languages
WHERE
    language_id = $1
LIMIT 1
`

func (q *Queries) GetLanguageById(ctx context.Context, languageID pgtype.UUID) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageById, languageID)
	var i Language
	err := row.Scan(
		&i.LanguageID,
		&i.LanguageName,
		&i.LanguageCode,
		&i.FlagEmoji,
		&i.Description,
	)
	return i, err
}

const getLanguageByName = `-- name: GetLanguageByName :one
SELECT
    language_id,
    language_name,
    language_code,
    flag_emoji,
    description
FROM languages
WHERE
    language_name = $1
LIMIT 1
`

func (q *Queries) GetLanguageByName(ctx context.Context, languageName string) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageByName, languageName)
	var i Language
	err := row.Scan(
		&i.LanguageID,
		&i.LanguageName,
		&i.LanguageCode,
		&i.FlagEmoji,
		&i.Description,
	)
	return i, err
}

const updateAdmin = `-- name: UpdateAdmin :exec
UPDATE admins
SET
    first_name = $1,
    last_name = $2,
    email = $3,
    password = $4,
    profile_image_url = $5
WHERE
    admin_id = $6 RETURNING admin_id,
    first_name,
    last_name,
    email,
    profile_image_url,
    joined_at
`

type UpdateAdminParams struct {
	FirstName       string      `json:"first_name"`
	LastName        string      `json:"last_name"`
	Email           string      `json:"email"`
	Password        string      `json:"password"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
	AdminID         pgtype.UUID `json:"admin_id"`
}

func (q *Queries) UpdateAdmin(ctx context.Context, arg UpdateAdminParams) error {
	_, err := q.db.Exec(ctx, updateAdmin,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.ProfileImageUrl,
		arg.AdminID,
	)
	return err
}
